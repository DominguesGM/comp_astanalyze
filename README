
**PROJECT TITLE: ASTANALYZE

**GROUP: 3MIEIC046ASTANALYZE

NAME1: Fábio André da Silva Amarante, NR1: 201007656, GRADE1: 18, CONTRIBUTION: 32%

NAME2: Gil Manuel Oliveira de Almeida Domingues, NR2: 201304646, GRADE2: 18, CONTRIBUTION: 36%

NAME3: Pedro Martins Pontes, NR3: 201305367, GRADE3: 18, CONTRIBUTION: 32%



** SUMMARY:

The tool developed generates two graphs, a control flow graph and a data dependency graph, given an abstract syntax tree.
The output is split into two dot files, one containing the control flow graph and another containing the data dependency graph.
The abstract syntax tree must be generated using spoon2ast.jar, a tool developed by Joao Bispo.



**DEALING WITH SYNTACTIC ERRORS: 

Upon finding an error in the abstract syntax tree, the tool will terminate, returning an error message.


**CODE GENERATION & INTERMEDIATE REPRESENTATION (IRs):

The code generated by this tool for the nodes consists of a partial reconstruction of the code from the abstract syntax tree, which means it is
considerably close to the java language.


**OVERVIEW:

ASTANALYZE processes each method in the given class (present in the AST) separately. It iterates through each line of code until finding 
a control structure. Upon finding a control structure, it follows a recursive approach, going one level lower in the abstract syntax tree,
and proceeding to iterate through every code line inside that control structure or until finding a break, continue or return statement.

A top down approach is followed for the AST processing, from a method header to the last line of code (or last return statement), adding 
a new node to the CFG as it processes a new line of code and connecting it to the graph.
During the processing of the code, usages and definitions of variables (dataflow) per code line are registered into an array, taking the form of the object
DataDependency. (done by CodeProcessor.java and CodeGenerator.java)

After the CFG has been generated and the uses and definitions of variables per code line have been registered, ASTANALYZE starts of a bottom-up approach,
taking each variable used and looking for the closest definition in the path created by each incoming edge. This is done to take into account every possible
variable definition that may be directly affecting that variable use. It does this for each line of code until it runs out of variable uses in each line.
The result are two parallel ArrayLists associated with each graph node, one with the variables it uses, and the other with the node where that variable was defined.

After analyzing each function in the class, it outputs two dot files, one with the control flow graph and the other with the data dependency graph.

The tool makes use of the graph library jgrapht for the graph construction and output as well as the json library json-simple.




**TESTSUITE AND TEST INFRASTRUCTURE: 



**TASK DISTRIBUTION: 

Fabio Amarante: Input and ouput handling;

Gil Domingues: abstract syntax tree parsing, control flow graph generation, part of data flow graph generation;

Pedro Pontes: data flow graph generation;


**PROS: 

This tool is prepared to analyze a java class containing multiple functions. In case there are multiple functions present
in the class, a graph is generated for each method (all the graphs are exported to the same CFG dot file). Even though there is
no edge connecting these graphs, for each method its header is present in the graph and method invocations from within a method body are 
explicit in that method's graph. The fact the graphs of different functions aren't connected was a design choice for the dot file to be more
easily visualized and more understandable when using a tool like graphviz.
The code generated for the construction of the graphs is designed to be easily interpreted, making it more suitable for presentation
purposes.
Every different control structure is supported (with the exception mentioned in the CONS section).




**CONS: 

This tool is entirely dependent of the spoon2ast.jar tool, give that it was this tool's specific output our tool was designed to process.
Some specific and less common control structures weren't accounted for, such as incomplete for loops (for example for(; i<0; i++) or even for(;;)).
The usage of this tool is limited to a single java class at a time, though using it separately on more than one class would achieve
similar results to what it would if multiple class support were to be implemented (the only difference being the graph existing in separate dot files)

